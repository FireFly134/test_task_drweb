# О проекте
Интерактивное консольное приложение, эмулирующее интерфейс СУБД. Вся "база" хранится в оперативной памяти и не сохраняется между сеансами. Поддерживаются вложенные транзакции и завершение по EOF.

### Требования из задания
> Интерактивное консольное приложение, напоминающее интерфейс базы данных. Данные запрашиваются у пользователя в диалоговом режиме (ввод с клавиатуры). Вся "база" находится в оперативной памяти и не сохраняется между сеансами. Одна команда — один запрос. Аргументы команд пробелов не содержат. Также во вводе должен распознаваться EOF, который означает конец ввода и завершение приложения.
> Также "база" должна поддерживать транзакции. Транзакции могут быть вложенными.


# Содержание
1. [Установка и запуск](#установка-и-запуск)
2. [Инструкция пользования](#инструкция-пользования)
3. [Нюансы реализации](#нюансы-реализации)
4. [Документация](#документация)

# Установка и запуск
- Требуется Python 3.10+ (тестировалось на Linux).
- Запуск из корня проекта:

```bash
  python3 python-task.py
```

# Инструкция пользования
Поддерживаемые команды:

### Базовые команды
- **SET X Y** — задать ключу с именем X значение Y
- **GET X** — вывести значение ключа X
- **UNSET X** — удалить ключ X
- **COUNTS Y** — вывести количество ключей, хранящих значение Y
- **FIND Y** — вывести имена ключей, хранящих значение Y
- **END** — завершить работу приложения (игнорирует глубину транзакций)

### Транзакции
- **BEGIN** — начать транзакцию
- **COMMIT** — применить и завершить текущую транзакцию
- **ROLLBACK** — отменить и завершить текущую транзакцию

Команды можно вводить в любом регистре.

# Нюансы реализации
- Использован специальный маркер-«сентинел» `DELETED`, чтобы отличать «ключ удалён» от «ключ никогда не существовал». Это корректно затеняет значения из нижних слоёв транзакций.
- Транзакции реализованы как стек слоёв (`dict`). `BEGIN` — добавляет слой за O(1); `ROLLBACK` — снимает верхний слой за O(1); `COMMIT` — сливает только изменённые ключи верхнего слоя во второй сверху.
- Чтения производятся «сверху вниз» через эффективный просмотр слоёв, что обеспечивает корректную семантику при вложенных транзакциях и удалениях.
- `COUNTS` и `FIND` работают по эффективным значениям: берут объединение всех ключей из слоёв и для каждого вычисляют актуальное значение. Это проще и надёжнее под транзакциями. Асимптотика O(K·L), что приемлемо для размера задачи.
- `FIND` сортирует имена ключей перед выводом — стабильный и детерминированный результат.
- Обработка ошибок и завершения: неизвестные команды/неверные аргументы печатают `ERROR`; `COMMIT`/`ROLLBACK` без активной транзакции печатают `NO TRANSACTION`; завершение — по `END` или EOF; `Ctrl+C` возвращает код 130.
- Команды регистронезависимы; пустые строки игнорируются.
- Возможные расширения: для ускорения `COUNTS`/`FIND` можно ввести обратный индекс/счётчики, но это усложнит корректную поддержку вложенных транзакций.

# Документация
### Класс `InMemoryDB`
Внутренняя СУБД на базе стековых слоёв для поддержки транзакций.

<details><summary>Атрибуты</summary>
<p>

- `_layers` (list[dict[str, object]]) — стек слоёв (базовый + транзакции)

</p>
</details>

<details><summary>Методы</summary>
<p>

- `set_value(key: str, value: str) -> None` — установить значение в текущем слое
- `get_value(key: str) -> str | None` — эффективное значение ключа либо `None`
- `unset_value(key: str) -> None` — пометить ключ удалённым в текущем слое
- `count_value(value: str) -> int` — количество ключей с данным значением
- `find_keys_by_value(value: str) -> list[str]` — список ключей с данным значением
- `begin() -> None` — начать транзакцию (добавить слой)
- `commit() -> bool` — слить верхний слой в нижний; `False`, если транзакций нет
- `rollback() -> bool` — откатить верхний слой; `False`, если транзакций нет

</p>
</details>
